---
diff: 入门
pid: B3854
name: [语言月赛 202309] 数组与内存 EV
tag: ['2023', 'O2优化', '分支结构', '语言月赛']
---
# [语言月赛 202309] 数组与内存 EV
## 题目描述

一维数组常常被想象为一个线性的数列，二维数组常常被想象为一个平面上的矩阵，三维数组常常被想象为空间中的一个立方体。由于我们生存在三维宇宙中，再高维度的数组的形态难以被想象，但是我们有理由认为，$n$ 维数组在 $n$ 维空间中可以被想象为一个几何体。

但是，无论数组的维数多高，计算机的内存空间总是线性的。
- C++ 在定义一维数组 $a[N]$ 时，会从 $a[0]$ 开始，在内存中连续申请 $N$ 个变量的**连续的**空间，依次分配给 $a[0],a[1],\cdots,a[N-1]$。

- 二维数组 $a[N][M]$ 可以看作 $N$ 个大小为 $M$ 的一维数组连续拼接在一起。C++ 在定义二维数组 $a[N][M]$ 时，会从 $a[0][0]$ 开始，在内存中申请 $N\times M$ 个变量的**连续的**空间，先排布 $a[0]$ 的一维数组，再依次排布 $a[1],a[2],\cdots,a[N-1]$ 的一维数组。排布规则与上面一维数组的情形相同。

- 更高维的数组以此类推。

众所周知，二维数组 $a[N][M]$ 可以使用的下标范围为 $a[0\sim N-1][0\sim M-1]$。但是，当定义了数组 $a[2][3]$，并使用了下标 $a[0][4]$，并不会访问非法内存，而是会访问到 $a[1][1]$。这是因为数组是依托于**连续线性**内存的，$a[0][4]$ 与 $a[1][1]$ 都是指向自 $a[0][0]$ 数起的（含 $a[0][0]$）第 $5$ 个变量，它们指向的内存地址是相同的。更高维度的数组亦有相同的机制。

现在，小 F 定义了一个二维数组 $a[N][M]$，并尝试访问 $a[p][q]$，请问小 F 是否会访问非法内存。
## 输入格式

输入一行四个非负整数，依次为 $N,M,p,q$。
## 输出格式

输出一行一个字符串：

- 若会访问非法内存，输出 `Segmentation fault.`。
- 若不会访问非法内存，输出 `Program ends with return value 0.`。
## 样例

### 样例输入 #1
```
4 2 2 3
```
### 样例输出 #1
```
Program ends with return value 0.
```
### 样例输入 #2
```
4 2 2 100
```
### 样例输出 #2
```
Segmentation fault.
```
## 提示

- 对于 $60\%$ 的测试数据，$1 \le N, M \le 10^4$, $0 \le p, q \le 10^4$；
- 对于 $100\%$ 的测试数据，$1 \le N, M \le 10^9$，$ 0 \le p, q \le 10^9$。
